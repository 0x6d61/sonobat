import type Database from 'better-sqlite3';
import crypto from 'node:crypto';
import type { Vulnerability } from '../../types/entities.js';
import type { CreateVulnerabilityInput } from '../../types/repository.js';

/**
 * Raw row shape returned by better-sqlite3 for the `vulnerabilities` table.
 * Column names are snake_case as defined in the schema.
 */
interface VulnerabilityRow {
  id: string;
  service_id: string;
  endpoint_id: string | null;
  vuln_type: string;
  title: string;
  description: string | null;
  severity: string;
  confidence: string;
  status: string;
  evidence_artifact_id: string;
  created_at: string;
}

/** Maps a snake_case DB row to a camelCase Vulnerability entity. */
function rowToVulnerability(row: VulnerabilityRow): Vulnerability {
  return {
    id: row.id,
    serviceId: row.service_id,
    endpointId: row.endpoint_id ?? undefined,
    vulnType: row.vuln_type,
    title: row.title,
    description: row.description ?? undefined,
    severity: row.severity,
    confidence: row.confidence,
    status: row.status,
    evidenceArtifactId: row.evidence_artifact_id,
    createdAt: row.created_at,
  };
}

/** Column list used in SELECT statements. */
const SELECT_COLUMNS =
  'id, service_id, endpoint_id, vuln_type, title, description, severity, confidence, status, evidence_artifact_id, created_at';

/**
 * Repository for the `vulnerabilities` table.
 *
 * All queries use prepared statements to prevent SQL injection.
 */
export class VulnerabilityRepository {
  private readonly db: Database.Database;

  constructor(db: Database.Database) {
    this.db = db;
  }

  /** Insert a new Vulnerability and return the full entity. */
  create(input: CreateVulnerabilityInput): Vulnerability {
    const id = crypto.randomUUID();
    const now = new Date().toISOString();

    const stmt = this.db.prepare(
      `INSERT INTO vulnerabilities (id, service_id, endpoint_id, vuln_type, title, description, severity, confidence, evidence_artifact_id, created_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
    );

    stmt.run(
      id,
      input.serviceId,
      input.endpointId ?? null,
      input.vulnType,
      input.title,
      input.description ?? null,
      input.severity,
      input.confidence,
      input.evidenceArtifactId,
      now,
    );

    return {
      id,
      serviceId: input.serviceId,
      endpointId: input.endpointId,
      vulnType: input.vulnType,
      title: input.title,
      description: input.description,
      severity: input.severity,
      confidence: input.confidence,
      status: 'unverified',
      evidenceArtifactId: input.evidenceArtifactId,
      createdAt: now,
    };
  }

  /** Find a Vulnerability by its primary key. Returns undefined if not found. */
  findById(id: string): Vulnerability | undefined {
    const stmt = this.db.prepare<[string], VulnerabilityRow>(
      `SELECT ${SELECT_COLUMNS} FROM vulnerabilities WHERE id = ?`,
    );

    const row = stmt.get(id);
    return row ? rowToVulnerability(row) : undefined;
  }

  /**
   * Return all Vulnerabilities for a given service.
   * Optionally filter by severity and/or status.
   */
  findByServiceId(serviceId: string, severity?: string, status?: string): Vulnerability[] {
    const conditions = ['service_id = ?'];
    const params: string[] = [serviceId];

    if (severity !== undefined) {
      conditions.push('severity = ?');
      params.push(severity);
    }
    if (status !== undefined) {
      conditions.push('status = ?');
      params.push(status);
    }

    const sql = `SELECT ${SELECT_COLUMNS} FROM vulnerabilities WHERE ${conditions.join(' AND ')}`;
    const stmt = this.db.prepare(sql);
    const rows = stmt.all(...params) as VulnerabilityRow[];
    return rows.map(rowToVulnerability);
  }

  /**
   * Return all Vulnerabilities across all services.
   * Optionally filter by severity and/or status.
   */
  findAll(severity?: string, status?: string): Vulnerability[] {
    const conditions: string[] = [];
    const params: string[] = [];

    if (severity !== undefined) {
      conditions.push('severity = ?');
      params.push(severity);
    }
    if (status !== undefined) {
      conditions.push('status = ?');
      params.push(status);
    }

    const whereClause = conditions.length > 0 ? ` WHERE ${conditions.join(' AND ')}` : '';
    const sql = `SELECT ${SELECT_COLUMNS} FROM vulnerabilities${whereClause}`;
    const stmt = this.db.prepare(sql);
    const rows = stmt.all(...params) as VulnerabilityRow[];
    return rows.map(rowToVulnerability);
  }

  /** Update the status of a vulnerability. Returns true if a row was updated. */
  updateStatus(id: string, status: string): boolean {
    const stmt = this.db.prepare<[string, string]>(
      'UPDATE vulnerabilities SET status = ? WHERE id = ?',
    );
    const result = stmt.run(status, id);
    return result.changes > 0;
  }

  /** Delete a Vulnerability by id. Returns true if a row was deleted. */
  delete(id: string): boolean {
    const stmt = this.db.prepare<[string]>('DELETE FROM vulnerabilities WHERE id = ?');
    const result = stmt.run(id);
    return result.changes > 0;
  }
}
