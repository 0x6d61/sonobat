import type Database from 'better-sqlite3';
import crypto from 'node:crypto';
import type { Cve } from '../../types/entities.js';
import type { CreateCveInput } from '../../types/repository.js';

/**
 * Raw row shape returned by better-sqlite3 for the `cves` table.
 * Column names are snake_case as defined in the schema.
 */
interface CveRow {
  id: string;
  vulnerability_id: string;
  cve_id: string;
  description: string | null;
  cvss_score: number | null;
  cvss_vector: string | null;
  reference_url: string | null;
  created_at: string;
}

/** Maps a snake_case DB row to a camelCase Cve entity. */
function rowToCve(row: CveRow): Cve {
  return {
    id: row.id,
    vulnerabilityId: row.vulnerability_id,
    cveId: row.cve_id,
    description: row.description ?? undefined,
    cvssScore: row.cvss_score ?? undefined,
    cvssVector: row.cvss_vector ?? undefined,
    referenceUrl: row.reference_url ?? undefined,
    createdAt: row.created_at,
  };
}

/**
 * Repository for the `cves` table.
 *
 * All queries use prepared statements to prevent SQL injection.
 */
export class CveRepository {
  private readonly db: Database.Database;

  constructor(db: Database.Database) {
    this.db = db;
  }

  /** Insert a new Cve and return the full entity. */
  create(input: CreateCveInput): Cve {
    const id = crypto.randomUUID();
    const now = new Date().toISOString();

    const stmt = this.db.prepare<
      [string, string, string, string | null, number | null, string | null, string | null, string]
    >(
      `INSERT INTO cves (id, vulnerability_id, cve_id, description, cvss_score, cvss_vector, reference_url, created_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
    );

    stmt.run(
      id,
      input.vulnerabilityId,
      input.cveId,
      input.description ?? null,
      input.cvssScore ?? null,
      input.cvssVector ?? null,
      input.referenceUrl ?? null,
      now,
    );

    return {
      id,
      vulnerabilityId: input.vulnerabilityId,
      cveId: input.cveId,
      description: input.description,
      cvssScore: input.cvssScore,
      cvssVector: input.cvssVector,
      referenceUrl: input.referenceUrl,
      createdAt: now,
    };
  }

  /** Find a Cve by its primary key. Returns undefined if not found. */
  findById(id: string): Cve | undefined {
    const stmt = this.db.prepare<[string], CveRow>(
      `SELECT id, vulnerability_id, cve_id, description, cvss_score, cvss_vector, reference_url, created_at
       FROM cves
       WHERE id = ?`,
    );

    const row = stmt.get(id);
    return row ? rowToCve(row) : undefined;
  }

  /** Return all Cves associated with a given vulnerability. */
  findByVulnerabilityId(vulnerabilityId: string): Cve[] {
    const stmt = this.db.prepare<[string], CveRow>(
      `SELECT id, vulnerability_id, cve_id, description, cvss_score, cvss_vector, reference_url, created_at
       FROM cves
       WHERE vulnerability_id = ?`,
    );

    const rows = stmt.all(vulnerabilityId);
    return rows.map(rowToCve);
  }

  /** Delete a Cve by id. Returns true if a row was deleted. */
  delete(id: string): boolean {
    const stmt = this.db.prepare<[string]>('DELETE FROM cves WHERE id = ?');
    const result = stmt.run(id);
    return result.changes > 0;
  }
}
